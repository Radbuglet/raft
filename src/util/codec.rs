use std::{error::Error, fmt};

// === Common === //

pub trait Codec: Sized + 'static {
    type Reader<'a>: ReadCursor<Pos = Self::ReaderPos>;
    type ReaderPos: ReadPos;

    type WriteElement<'a>: ?Sized;

    fn covariant_cast<'a: 'b, 'b>(reader: Self::Reader<'a>) -> Self::Reader<'b>;
}

pub trait ReadCursor: Sized + Clone {
    type Pos: ReadPos;

    fn pos(&self) -> Self::Pos;

    fn set_pos(&mut self, pos: Self::Pos);
}

pub trait ReadPos: Sized + 'static + Copy + Eq {}

impl<T: 'static + Copy + Eq> ReadPos for T {}

pub trait WriteStream<E: ?Sized> {
    type Error: 'static + Error + Send + Sync;

    fn push(&mut self, elem: &E) -> Result<(), Self::Error>;
}

// === Deserialize === //

pub trait Deserialize<C: Codec>: Sized + 'static {
    /// A summary of the deserialized contents. This includes enough information to:
    ///
    /// 1. Determine the position of sub-fields quickly given the starting position of the object.
    /// 2. Decode its contents quickly given the backing stream.
    /// 3. Determine the starting position of the next object quickly given the starting position of
    ///    this object.
    ///
    type Summary: 'static + fmt::Debug + Clone;

    /// A user-friendly view into the contents of this object given a bound backing buffer.
    ///
    /// This view should be lazily evaluated and must provide a mechanism for reifying the view into
    /// its regular type.
    type View<'a>: fmt::Debug + Into<Self>;
}

pub trait DeserializeFor<C: Codec, A>: Deserialize<C> {
    /// Validates and summarizes an input stream, leaving the `cursor` head at the position of
    /// the next item if it exists.
    fn summarize(cursor: &mut C::Reader<'_>, args: &mut A) -> anyhow::Result<Self::Summary>;

    /// Produces a user-friendly view of a summary. It should always be valid to construct this view
    /// since summarization should have already performed all the necessary validation.
    ///
    /// ## Safety
    ///
    /// Callers assert that:
    ///
    /// - The `summary` was generated by this `impl` block's [`summarize`](DeserializeFor) method and
    ///   not some other `impl` with the same `summary` type.
    ///
    /// - The `summary` was generated using the same backing buffer as is being provided in the
    ///   `cursor`.
    ///
    /// Note that there is *no guarantee* that:
    ///
    /// - The `args` provided are the same as the arguments provided to `summarize`.
    /// - The exact type of the arguments is identical since one may have blanket `impl`'d this trait
    ///   for several argument types.
    /// - The cursor is in the same place as it was when the summary was generated.
    ///
    unsafe fn view<'a>(
        summary: &'a Self::Summary,
        cursor: C::Reader<'a>,
        args: &mut A,
    ) -> Self::View<'a>;

    /// Skips a cursor starting at the beginning of this element to the start of the next element.
    fn skip(summary: &Self::Summary, cursor: &mut C::Reader<'_>, args: &mut A);

    /// Decodes the reified version of this value in a single pass.
    fn decode<'a>(cursor: &'a mut C::Reader<'_>, args: &mut A) -> anyhow::Result<Self> {
        let fork = cursor.clone();
        let summary = Self::summarize(cursor, args)?;

        let view = unsafe {
            // Safety: we just generated this summary with the appropriate cursor.
            Self::view(&summary, C::covariant_cast(fork), args)
        };

        Ok(view.into())
    }
}

// === DeserializeForSimples === //

pub trait DeserializeForSimple<C: Codec, A>: Deserialize<C> {
    fn decode_simple<'a>(
        cursor: &mut C::Reader<'a>,
        args: &mut A,
    ) -> anyhow::Result<Self::View<'a>>;
}

pub trait SimpleSummary<C: Codec>: ReadPos {
    fn from_pos(pos: C::ReaderPos) -> Self;

    fn skip_to_end<A, T>(self, cursor: &mut C::Reader<'_>, args: &mut A)
    where
        T: DeserializeForSimple<C, A>;
}

impl<C: Codec> SimpleSummary<C> for () {
    fn from_pos(_pos: C::ReaderPos) -> Self {
        ()
    }

    fn skip_to_end<A, T>(self, cursor: &mut C::Reader<'_>, args: &mut A)
    where
        T: DeserializeForSimple<C, A>,
    {
        let _ = T::decode_simple(cursor, args);
    }
}

#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
pub struct EndPosSummary<P>(pub P);

impl<C: Codec> SimpleSummary<C> for EndPosSummary<C::ReaderPos> {
    fn from_pos(pos: C::ReaderPos) -> Self {
        Self(pos)
    }

    fn skip_to_end<A, T>(self, cursor: &mut C::Reader<'_>, _args: &mut A)
    where
        T: DeserializeForSimple<C, A>,
    {
        cursor.set_pos(self.0);
    }
}

impl<C, A, T> DeserializeFor<C, A> for T
where
    C: Codec,
    T: DeserializeForSimple<C, A>,
    T::Summary: SimpleSummary<C>,
{
    fn summarize(cursor: &mut C::Reader<'_>, args: &mut A) -> anyhow::Result<Self::Summary> {
        Self::decode_simple(cursor, args)?;
        Ok(SimpleSummary::from_pos(cursor.pos()))
    }

    unsafe fn view<'a>(
        _summary: &'a Self::Summary,
        cursor: C::Reader<'a>,
        args: &mut A,
    ) -> Self::View<'a> {
        Self::decode_simple(&mut cursor.clone(), args).unwrap()
    }

    fn skip(summary: &Self::Summary, cursor: &mut C::Reader<'_>, args: &mut A) {
        summary.skip_to_end::<A, T>(cursor, args)
    }
}

// === Serialize === //

pub trait SerializeInto<C: Codec, T, A>: Sized {
    fn serialize(
        &self,
        stream: &mut impl for<'a> WriteStream<C::WriteElement<'a>>,
        args: &mut A,
    ) -> anyhow::Result<()>;
}

// === Sequential Struct === //

pub mod codec_struct_internals {
    pub use {
        super::{Codec, Deserialize, DeserializeFor, ReadCursor, SerializeInto, WriteStream},
        anyhow,
        std::{
            clone::Clone,
            convert::{identity, From},
            fmt,
            result::Result::Ok,
            stringify,
        },
    };
}

macro_rules! seq_codec_struct {
    ($(
        $(#[$attr:meta])*
        $struct_vis:vis struct $mod_name:ident::$struct_name:ident($codec:ty) {
            $($field_name:ident: $field_ty:ty $(=> $config_ty:ty : $config:expr)?),*
            $(,)?
        }
    )*) => {$(
        $struct_vis mod $mod_name {
            #[allow(unused_imports)]
            use super::*;

            // Structure definitions
            $(#[$attr])*
            pub struct $struct_name {
                $(pub $field_name: $field_ty,)*
            }

            #[derive(Debug, Copy, Clone)]
            pub struct Summary {
                $($field_name: <$field_ty as $crate::util::codec::codec_struct_internals::Deserialize<$codec>>::Summary,)*
            }

            #[derive(Clone)]
            pub struct View<'a> {
				// Safety invariant: the cursor and all the summary's elements have the same backing buffer.
                summary: &'a Summary,
                cursor: <$codec as $crate::util::codec::codec_struct_internals::Codec>::Reader<'a>,
            }

            #[derive(Debug, Copy, Clone)]
            #[allow(non_camel_case_types)]
            pub struct Builder<$($field_name,)*> {
                $(pub $field_name: $field_name,)*
            }

            // Deserialization
            impl $crate::util::codec::codec_struct_internals::Deserialize<$codec> for $struct_name {
                type Summary = Summary;
                type View<'a> = View<'a>;
            }

            impl $crate::util::codec::codec_struct_internals::DeserializeFor<$codec, ()> for $struct_name {
                fn summarize(
                    cursor: &mut <$codec as $crate::util::codec::codec_struct_internals::Codec>::Reader<'_>,
                    _args: &mut (),
                ) -> $crate::util::codec::codec_struct_internals::anyhow::Result<Self::Summary> {
					let _ = &cursor;

                    $crate::util::codec::codec_struct_internals::Ok(Summary {$(
						#[allow(unused_parens)]
						$field_name: <$field_ty as $crate::util::codec::codec_struct_internals::DeserializeFor::<$codec, ($($config_ty)?)>>::summarize(
                            cursor,
                            &mut {$($config)?},
                        )?,
					)*})
                }

                unsafe fn view<'a>(
                    summary: &'a Self::Summary,
                    cursor: <$codec as $crate::util::codec::codec_struct_internals::Codec>::Reader<'a>,
                    _args: &mut (),
                ) -> Self::View<'a> {
					// Safety: the caller guarantees that the summary was generated using this cursor's
					// backing buffer. Because every sub-summary created by `summarize` was also
					// generated by a cursor derived from this backing buffer, they too have the
					// appropriate backing buffer, satisfying this structure's safety invariants.
                    Self::View { summary, cursor }
                }

                fn skip(
                    summary: &Self::Summary,
                    cursor: &mut <$codec as $crate::util::codec::codec_struct_internals::Codec>::Reader<'_>,
                    _args: &mut (),
                ) {
					let _ = (summary, &cursor);

                    $(
						#[allow(unused_parens)]
                        <$field_ty as $crate::util::codec::codec_struct_internals::DeserializeFor<$codec, ($($config_ty)?)>>::skip(
                            &summary.$field_name,
                            cursor,
                            &mut {$($config)?},
                        );
                    )*
                }
            }

            // View accessors
			struct OffsetsTmp {
				$($field_name: <$codec as $crate::util::codec::codec_struct_internals::Codec>::ReaderPos,)*
			}

			impl View<'_> {
				fn offsets(&self) -> OffsetsTmp {
					let mut cursor = $crate::util::codec::codec_struct_internals::Clone::clone(&self.cursor);

                    $(
						let $field_name = $crate::util::codec::codec_struct_internals::ReadStream::pos(&cursor);

						#[allow(unused_parens)]
						<$field_ty as $crate::util::codec::codec_struct_internals::DeserializeFor<$codec, ($($config_ty)?)>>::skip(
                            &self.summary.$field_name,
                            &mut cursor,
                            &mut {$($config)?},
                        );
                    )*

					OffsetsTmp { $($field_name,)* }
				}
			}

            impl<'a> View<'a> {$(
                pub fn $field_name(&self) -> <$field_ty as $crate::util::codec::codec_struct_internals::Deserialize<$codec>>::View<'a> {
					let offset = self.offsets().$field_name;
					let mut config = {$($config)?};

					let mut cursor = $crate::util::codec::codec_struct_internals::Clone::clone(&self.cursor);
					$crate::util::codec::codec_struct_internals::ReadStream::set_pos(&mut cursor, offset);

					unsafe {
						// Safety: by invariant, we know the summary, its sub-element summaries, and
						// its cursor were all derived from the same backing buffer, making this call
						// valid. We know the config type is constant because `$config_ty` fixes it
						// to a value.
						#[allow(unused_parens)]
						<$field_ty as $crate::util::codec::codec_struct_internals::DeserializeFor<$codec, ($($config_ty)?)>>::view(
							&self.summary.$field_name,
							cursor,
							&mut config,
						)
					}
                }
            )*}

            // View reification
            impl $crate::util::codec::codec_struct_internals::From<View<'_>> for $struct_name {
                fn from(view: View<'_>) -> Self {
					let _ = &view;

                    Self {
                        $($field_name: $crate::util::codec::codec_struct_internals::From::from(view.$field_name()),)*
                    }
                }
            }

            // View formatting
            impl $crate::util::codec::codec_struct_internals::fmt::Debug for View<'_> {
                fn fmt(&self, f: &mut $crate::util::codec::codec_struct_internals::fmt::Formatter<'_>) -> $crate::util::codec::codec_struct_internals::fmt::Result {
                    f.debug_struct($crate::util::codec::codec_struct_internals::stringify!($struct_name))
                        $(.field(
                            $crate::util::codec::codec_struct_internals::stringify!($field_name),
                            &self.$field_name(),
                        ))*
                        .finish()
                }
            }

            // Serialization
            #[allow(non_camel_case_types, unused_parens)]
            impl<$($field_name,)*> $crate::util::codec::codec_struct_internals::SerializeInto<$codec, $struct_name, ()> for Builder<$($field_name,)*>
            where
                $($field_name: $crate::util::codec::codec_struct_internals::SerializeInto<$codec, $field_ty, ($($config_ty)?)>,)*
            {
                fn serialize(
					&self,
					stream: &mut impl for<'a>
						$crate::util::codec::codec_struct_internals::WriteStream<
							<$codec as $crate::util::codec::codec_struct_internals::Codec>::WriteElement<'a>>,
					_args: &mut (),
				) -> $crate::util::codec::codec_struct_internals::anyhow::Result<()> {
					let _ = &stream;

					$(
						$crate::util::codec::codec_struct_internals::SerializeInto::<$codec, $field_ty, ($($config_ty)?)>::serialize(
							&self.$field_name,
							stream,
							&mut {$($config)?},
						)?;
					)*

					$crate::util::codec::codec_struct_internals::Ok(())
				}
            }

			// TODO: Ensure that reified form can also serialize.
        }

        #[allow(unused_imports)]
        $struct_vis use $mod_name::$struct_name;
    )*};
}

pub(crate) use seq_codec_struct;
